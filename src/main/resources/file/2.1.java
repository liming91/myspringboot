//*基础知识:
//== 和 equals 的区别    ==对于基本类型而言比较的是对象的值,对于对象而言比较的是对象的地址  而equals比较的是两个对象的内容是否相等
//  本质是1.基础类型比较使用==比较值是否相等,如果用==比较是对象的引用是否指向同一个内存地址.而重写了equals的方法的对象比如(String) 比较的是引用对象的内容是否相等. 如果没用重写equals则  == 和equals 比较的都是对象的引用是否指向同一个内存地址
//  ==比较的是地址,也就是两个对象的引用是否指向同一个对象,而equals方法在没有重写前底层依旧使用的是
//  equals 和 hashCode 的区别   如果想要获取一个集合内的 某个元素的话  如果不通过indexOf的话 则需要遍历判断,再将需要的元素返回,使用HashCode的话可以吧每个元素看做一个存储区域,一个区域对应一个hashCode值,一个对象一般是有key 和 value的,根
//线程 和 进程  Java的线程是通过Thread类来实现的  如Main方法  其实也是隐式调用线程 下载的java.exe编译来执行main函数
//
//String和StringBuilder和StringBuffer的区别  String类是不可变的 如果需要改变则JVM会重新创建一个String对象  因此改变String的时候是JVM不断创建回收对象的一个过程效率上比较慢 且String底层的是Chart数组形式,且chart数组是被final修饰的,所以String是不不可改变的
//StringBuilder和StringBuffer则不同,他们是相对于对对象的变量进行操作的,不会反复的创建回收对象,在效率上是StringBuilder 高于StringBuffer的.
//StringBuilde线程不安全没有被synchronized修饰,StringBuffer是线程安全的在考虑效率的情况下建议使用StringBuilder 考虑线程安全的情况下建议使用StringBuffer;
//
//集合面试题:
//Map接口和Collection接口是所有集合的父接口
//Collection:Set结合----List集合
//Set集合 (线程都不是安全的,不可重复集合(在执行添加元素的时候采用了equals去判断是否相等,如果相等则放回一个boolean值(false),在获取元素只能以 Iterator 接口取得所有的元素，再逐一遍历各个元素取得所需元素),使用哈希表进行存储,存入与取出的顺序是不一致的,):
//	HashSet:
//	(实现了Set接口有,底层由Hash表(实际上就是一个HashMap实例)支持,不保证set的迭代顺序,在HashSet中元素都存放在HashMap键值对Key中,
//	而Value则是一个统一的值(既定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)对于HashSet中保存的对象，主要要正确重写equals方法和hashCode方法，以保证放入Set对象的唯一性.HashSet没有提供get方法原因是和HashMap一样
//	,set的内部是无序的,只能通过迭代的方式来获取),
//
//	TreeSet(线程不安全的):
//	TreeSet集合中存放的元素是有序的,但是并不是按照插入顺序存放,而是根据关键字大小进行排序的,并且元素也不能重复.TreeSet的底层是用TreeMap实现的,TreeSet会在构造方法中创建一个TreeMap的实例,用于存放元素底层其实就是TreeMap.
//
//	LinkedHashSet:
//	存放的是一个值,并且元素不能重复.如果需要遍历只能使用迭代器Iterator,和增强For循环来进行遍历.LinkedHashSert继承于HashSert,底层采用了LinkedhashMap来保存所有元素,并且只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。
//List集合(是存储单列数据的集和,且可重复,有序的):
//	 ArrayList(线程不安全,有序的集合,插入的顺序==输出的顺序,并且允许有null值,而且底层是基于数组实现的,采用懒加载的方式,
//	 第一次add元素的时候会初始化数组,默认初始化的大小为10,他允许对元素的快速随机访问以及在链表尾部进行插入或删除元素操作,
// 	 当插入元素的时候如果此时数组的大小已经不能满足再插入元素的时候就会进行扩容,采用数组的array.copyof的方法将已经插入的元素
// 	 复制到新的存储空间中去,由此可见ArrayLsit适合随机访问并不适合插入以及删除.)
//
//	LinedList(线程不安全,双向链表,所以增加和删除的时候效率较高,但是没有索引,涉及到对索引的操作是较为麻烦,需要进行循环遍历,
//	每次循环的时候都需要进行一个判断,判断这个元素位于链表的前部分还是后部分，所以随机访问的效率要比较低.)
//
//	Vector(和ArrayList类似都是基于数组进行实现的,在实例化对象是也是初始数组长度为10,且Vector是线程安全的,
//	即在多线程的环境下，能保证同一时间只有一个线程能够操控Vector，保证了数据的一致性,采用synchronized来进行修饰
//	,真是因为Vector集合是安全线程所以导致了性能相对于ArrayList低了许多.)
//
//Map集合 (存储形式是以Key-Value形式存储的,并且是无序的,Key是唯一的不能重复,value是可以重复的):
//	HashMap(首先Hashmap的底层数据结构是由数组+链表组成的，是线程不安全，允许key和value为null。
//	Collections.synchronizedMap来获取安全线程的HashMap底层结构数组叫哈希桶，而桶内则是链表，
//	链表中的节点Node存放着实际的元素)Key怎么判断重复性,以及HashMap的容量  JDK1.7 和1.8区别
//
//
//	优缺点:优点：插入删除速度快，内存利用率高，没有大小固定，扩展灵活。
//	       缺点：不能随机查找，每次都是从第一个开始遍历.
//	put原理:第一步：首先将k,v封装到Node对象当中（节点）
//		第二步：通过哈希算法计算出当前key的hash值
//		第三步：再通过哈希表函数/哈希算法，将hash值转换成数组的下标，下标位置上如果没有任何元素，就把Node添加到这个位置上。
//		如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。
//		如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末
//		尾。如其中有一个equals返回了true，那么这个节点的value将会被覆盖。
//
//		首先判断,判断是否初始化(通过table  == emyty_table)没有初始化的达标哈希桶的空间还没有开辟出来,调用inflatetable
//		来进行空间的膨胀(也就是开辟出新的空间)开辟空间的时候是向上取证为2的幂次方,默认为16,先调用k的hashCode()方法得出哈希值,
//		并通过哈希算法转换成数组的下标。如果说下标对应的位置上有链表。此时，就会拿着k和链表上每个节点的k进行equal。
//		如其中有一个equals返回了true，那么这个节点的value将会被覆盖。
//		如果所有的equals方法返回都是false，那么这个新的节点将被添加到链表的末尾。
//
//
//	为什么是2的倍数:
//		因为向数组内添加元素的时候会使用(n - 1) & hash的计算方法来得出该元素在集合中的位置,而需要扩容的时候会调用resize
//		方法,会新建一个数组，然后遍历旧的数组，将旧的元素通过算法(也就是(n - 1) & hash的计算方法)的计算添加进新的数组中
//		其中n是集合的容量，hash是添加的元素进过hash函数计算出来的hash值.
//		HashMap的容量为什么是2的n次幂，和这个(n - 1) & hash的计算方法有着千丝万缕的关系，符号&是按位与的计算，
//		按位与&的计算方法是，只有当对应位置的数据都为1时，运算结果也为1，
//		当HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时
//		，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。
//
//	什么是Hash冲突
//		数组的长度是5。这时有一个数据是6。那么如何把这个
//		6存放到长度只有5的数组中呢。按照取模法，计算
//		6％5，结果是1，那么就把6放到数组下标是1的位置。那么，7
//		就应该放到2这个位置。到此位置，哈斯冲突还没有出现。
//		这时，有个数据是11，按照取模法，11％5＝1，也等于1。那么
//		原来数组下标是1的地方已经有数了，是6。这时又计算出1这个
//		位置，那么数组1这个位置，就必须储存两个数了这就叫
//		哈希冲突。冲突之后就要按照顺序来存放了。
//	红黑树的机制
//		红黑树的根本是一种特化的平衡二叉树：
//		1.所有节点最多拥有两个子节点，长度不大于2；
//		2.左子树的键值小于根的键值，右子树的键值大于根的键值；
//		3.任何节点的两个子树的高度最大差为1。
//		红黑树核心是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。红黑树有5个特点在平衡过程中作为依据：
//		1.每个节点只有两种颜色：红色或者黑色
//		2.根节点必须是黑色
//		3.每个叶子节点（NIL）都是黑色的空节点
//		4.从根节点到叶子节点，不能出现两个连续的红色节点
//		5.从任一节点出发，到它下边的子节点的路径包含的黑色节点数目都相同
//	扩容机制:
//		在进行元素put的时候底层会调用putVal分方法,在putVal的方法中，当第一次向HashMap中添加对象时，会进行一个判空的处理.
//		这时就调用resize()方法对HashMap进行容量设置，此时会有两种情况的根据容量初始化。
//		第一种情况：当我们没有设置初始化容量时，HashMap就使用默认的初始化容量，也就是16.
//		第二种情况: 当我们设置了初始容量的时候不一定按照我们设置的初始容量进行设置,当初始容量为2的N次方的时候,就会按照
//		我们设置的初始容量进行设置,当设置的初始容量不是2的N次方的时候,就会取接近你设置的那个值的2的n次方进行设置。
//		在put的时候,size代表的是HashMap中键值对的数量,如果键值对的数量大于当前容量*0.75(阈值)
//		HashMap会进行扩容操作调用resize方法进行扩容,扩容是以2倍的容量进行一个扩容.
//	HashMap为什么是不是线程安全的
//		在put的时候，因为该方法不是同步的，假如有两个线程A,B它们的put的key的hash值相同，不论是从头插入还是从尾插入,
//		假如A获取了插入位置为x，但是还未插入，此时B也计算出待插入位置为x，则不论AB插入的先后顺序肯定有一个会丢失.
//	HashMap线程安全的三种方法:
//		1.使用HashTable(此方法效率较低)
//		2.使用Collections的SynchronizedMap方法(同样性能较低)
//	SynchronizedMap是如何实现线程安全的:
//		在SynchronizedMap中维护了一个普通的Map对象,还有排它锁mutex,也就是这两个参数,在调用的时候需要传入一个Map
//		对象,如果传入了mutex则将对象排斥锁赋值为传入的对象。如果没有传入mutex参数,那么将对象排斥锁赋值为当前对象,
//		就是调用synchronizedMap的对象,创建出synchronizedMap的对象之后,在操作Map的时候就会对方法上锁.
//
//
//		方案1 和 2 无论是读写操作都会给整个集合进行上锁,导致同一个时间的其他操作被阻塞了.
//	多线程下使用ConcurrentHashMap与HashMap和HashTable的区别
//		1.HashMap:
//		多线程的情况下,不能使用HashMap 因为他不是线程安全的(put方法在多线程的情况下可能会导致闭环,因为多线程可以导致
//		HashMap形成环形链表,就是链表的下一个节点的next节点永远不为null,就会产生闭环,此时CPU的占用率会打到100%,所以并
//		发的情况下不能使用HashMap)
//		2.HashTable:
//		HashTable通过使用synchronized保证线程安全，但在线程竞争激烈的情况下效率低下。因为当一个线程访问HashTable的同
//		步方法时，其他线程只能阻塞等待占用线程操作完毕.效率较低.
//		3.使用ConcurrentHashMap
//		ConcurrentHashMap使用分段锁的思想，对于不同的数据段使用不同的锁，可以支持多个线程同时访问不同的数据段，这样
//		线程之间就不存在锁竞争，从而提高了并发效率。
//		实现原理:
//		在JDK7  和 JDK8 中ConcurrentHashMap实现是不同的
//		JDK7:
//		    JDK7他的数据结构是Segment数组,HashEntry链表形式,数据结构和HashMap类似仍然是数组加链表的形式.
//		    Segment 是ConcurrentHashMap  的一个内部类,主要的还是由HashEntry 组成,但是Segment的HashEntry
//		    使用了volatile修饰,主要是保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变
//		    量的值，这新值对其他线程来说是立即可见的。原理上ConcurrentHashMap 采用了分段锁技术其中 Segment 继
//		    承于 ReentrantLock,不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理,每当一个线
//		    程占用锁访问一个 Segment 时，不会影响到其他的 Segment。就是说如果容量大小是16他的并发度就是
//		    16，可以同时允许16个线程操作16个Segment而且还是线程安全的.他先定位到Segment，然后再进行put操作。第一步的时候会尝试获取锁,如果
//		    获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。尝试自旋获取锁。如
//		    果重试的次数达到了最大充实扫描次数,则改为阻塞锁获取，保证能获取成功
//		    get逻辑：
//		    只需要将 Key 通过 Hash算法之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。由于 HashEntry 中的 value 属
//		    性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。他的get效率是很高的，因为整个过程中是不需要进
//		    行加锁操作的。
//		 1.7存在的问题:
//		    因为基本上还是数组加链表的方式，我们去查询的时候，还得遍历链表，会导致效率很低
//
//		JDK8:
//		    其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性,而且和HashMap类似,只是把
//		HashEntry改成了Node,值和next采用了volatile去修饰，保证了可见性.
//		Put的时候需要进行的操作:
//		1.根据Key计算出HashCode.
//		2.判断是否需要进行初始化。
//		3.根据当前key定位出的node节点,如果为空则表示当前位置可以写入数据,然后再利用CAS产生写入,如果失败进行自旋,保证
//		成功.自旋(是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。)
//		4.如果都不满足，则利用 synchronized 锁写入数据。
//		5.如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。
//		主要采用了CAS
//		CAS 是乐观锁的一种实现方式，
//		主要是使用了CAS算法来实现线程的安全性,CAS需要有三个操作数,一个是内存地址V,旧的预期值A,和即将要更新的更新值B,
//		当内存地址V与预期值A相等的时候,将内存地址V修改为更新值B,否则的话什么都不做,并且整个的替换过程是一个原子性的
//		过程.就比如我现在要修改数据库的一条数据，修改之前我先拿到他原来的值，原来的值和我手上
//		拿到的他的原来的值是否一样，一样我们就可以去修改了，不一样就证明被别的线程修改了。
//		但是CAS也不一定能够保证数据没有被别的线程修改过.一个很经典的问题如ABA问题
//		比如有一个值是A,有一个线程把值改回了B,又来了一个线程把值又变回了A,对于这个时候判断线程就会发现他的值还是原来的A,
//		所以不知道他到底有没有没更改过,这种场景如果只针对追求结果来说的话时没有问题的,但是有时候需要记录过程,比如资金的
//		修改之类的,每次修改都会有记录,解决的方法就是加上一个时间戳,查询的时候将时间也查出来,对于前一次修改的时候将时间也
//		修改了,这样也能解决刚刚的那个问题.
//
//get原理:第一步：先调用k的hashCode()方法得出哈希值，并通过哈希算法转换成数组的下标。
//		第二步：通过上一步哈希算法转换成数组的下标之后，在通过数组下标快速定位到某个位置上。
//		重点理解
//		如果这个位置上什么都没有，则返回null。
//		如果这个位置上有单向链表，那么它就会拿着参数K和单向链表上的每一个节点的K进行equals，如果所有equals方法都返回false，则get方法返回null。
//		如果其中一个节点的K和参数K进行equals返回true，那么此时该节点的value就是我们要找的value了，get方法最终返回这个要找的value。
//		为和增删改查询的效率都比较高:
//		原因：增删是在链表上完成的，而查询只需扫描部分所以效率高.
//	为什么放在hashMap集合key部分的元素需要重写equals方法？
//		因为equals默认比较是两个对象内存地址.
//	为什么不可重复
//		使用equals方法来保证HashMap集合key不可重复，如key重复来，value就会覆盖。存放在HashMap集合key部分的元素，其实就是存放在HashSet集合中，则HashSet集合也需要重写equals和hashCode方法。
//	总结:
//		无序不可重复(因为不一定挂到哪一个单向链表上的，因此加入顺序和取出也不一样.)
//		hashmap集合的默认初始化容量为16，默认加载因子为0.75，也就是说这个默认加载因子是当hashMap集合底层数组的容量达到75%时，数组就开始扩容。
//		hashmap集合初始化容量是2的陪数，为了达到散列均匀，提高hashmap集合的存取效率(如果不是2的倍数,底层会修改为2的倍数)
//	JDK1.8之后
//		如果哈希表单向链表中元素超过8个，那么单向链表这种数据结构会变成红黑树数据结构。当红黑树上的节点数量小于6个，
//
//	LinkedHashMap (首先Key和value都允许为空,key重复的时候会覆盖原有key,value重复的时候则不会覆盖,他的内部是有序的,不是线程安全的
//	LinkedHashMap 是HashMap的一个子类,因为继承与HashMap所以他的底层也是和HashMap类似的实现了Map接口,通过数组和链表+红黑树,
//	但是在次的基础上LinkedHashMap增加了一个双向链表,保持遍历顺序,以及插入顺序一致的问题.和HashMap相比,他重新定义了数组中
//	保存元素的Entry,该Entry除了保存当前的对象外的引用外,还保存了其上一个元素(before)和下一个元素after的引用,从而在哈希表
//	的基础上构成了双向链表.
//
//	HashTable(基于哈希表实现的,每个元素都是以Key-value形式存在的,内部通过单链接表解决冲突问题,容量不足时会自增长,
//	Hashtable中key和value都不允许为null.再执行put方法的时候,首先获取锁(synchronized,)put的方法不允许有null的存在,
//	如果发现有null会直接抛出空指针的异常,计算key的hash值和index遍历对应位置的链表,如果发现已经存在相同的hash和key时
//	则会跟新value,并且将旧的值进行返回,如果不存在相同的key的Entry节点，则调用addEntry方法增加节点。
//	addEntry方法中，如果需要则进行扩容，之后添加新节点到链表头部。Hashtable扩容时，将容量变为原来的2倍加1线程安全的,
//	所有的读写操作都进行了锁(synchronized)的保护,多线程的情况下可以考虑使用,但是对读写的效率有较大影响)
//
// SpringIOC
// 什么是SpringIOC:
// SpringIOC(控制反转),SpringIOC主要是为了解决对象之间的耦合度过高的问题,开发者自己不用去管理和实例化JavaBean(对象),
// 而由Spring帮助开发者管理和实例化JavaBean,这样做主要是省去了管理和实例化对象的过程,开发者拿来即可使用.节省开发时间
// ,提高开发效率,通过(xxxxx.xml)文件来配置javaBean只需要读取配置文件中的Bean对象即可,这个配置文件就是Spring的容器.
// 底层基于单例模式来实例化对象,通过打印对象的hashCode两个相同对象的HashCode是一样的.
// 实现原理:
//	底层主要是通过了调用BeanFactory中的getBean方法来进行实例化对象,该方法是abstactBeanFactory中的一个抽象方法,他通过
//	DefaultSingletonBeanRegistry实现类中的单例方法getSingleton来进行实例化对象的.
// ).
// BeanFactor 和factoryBean的区别:
//什么是SpringBoot:
//	举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot
//	就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。
//	如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。
//	SpringBoot最核心的是 @EnableAutoConfiguration注解,它能根据类路径下的 jar 包和配置动态加载配置和注入bean。
//
//SpringBoot:
//	SpringBoot自动配置原理:
//	@SpringBootApplication,它是SpringBoot的核心注解.而且他是一个符合注解,SpringBootApplication中有一个注解,EnableAutoConfiguration
//	注解,这个注解主要是开启自动配置,而这个注解也是一个派生注解,其中的关键功能由 @Import提供，其导入的
//	AutoConfigurationImportSelector的selectImports()方法通过SpringFactoriesLoader.loadFactoryNames()扫描所有具有META-INF/spring.factories的jar包。
//	spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件.这个Spring.factories文件存储也是以Key-Value形式
//	,其中一个key是EnableAutoConfiguration类,而他所对应的value是一个以AutoConfiguration结尾的类名的列表,这个 @EnableAutoConfiguration
//	注解通过 @SpringBootApplicatioon被间接的标记在了SpringBoot的启动类上,在执行SpringApplication.run方法的内部就会执行selectImports
//	方法,找到所有JavaConfig自动配置类的全限定名对应的class，然后将所有自动配置类加载到Spring容器中进行启动.
//
//
//Spring
// 1.通过Spring的相关类读取Spring的容器文件(BeanFactory.ClassPathApplicationContext方法获取Spring文件)
// 2.获取Spring容器中的JavaBean对象.(通过beanFactory的getBean方法获得JavaBean对象)
// 3.调用Spring相关类的方法进行实例化对象.
// 装配Bean的方法(
// 1. @Autowired(aotu wei red))(注入Bean是按照byType注入的)
// 2. @Resource (注入Bean的时候是按照byName注入的)
// 3. 通过getBean("beanID")方法来自动装配
// @Autowired默认按类型匹配的方式，在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中.
// @Resource和@Autowired都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用。
// 不同点
// @Resource是Java自己的注解，@Resource有两个属性是比较重要的，分是name和type；Spring将@Resource注解的name属性解析为bean的名字，
// 而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。
// 如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。
//
//控制反转: 就是创建对象的控制权，被反转到了Spring框架上。
//    通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，
//    而控制反转就把new对象的工交给了Spring容器。依赖注入：由IoC容器动态地将某个对象所需要的外部资源（包括对象、资源、常量数据）
//    注入到组件(Controller, Service等）之中。简单点说，就是IoC容器会把当前对象所需要的外部资源动态的注入给我们。
//    DI依赖注入:
//    指 Spring 创建对象的过程中，将对象依赖属性（简单值，集合，对象）通过配置设值给该对象
//    创建一个饭点的类,饭点内一定有吃的 喝的 等,吃的如米饭  饺子等,喝的有果汁,汽水等.这些都是饭店里面的属性,此时我们想点吃的和
//    喝的,比如点饺子,和果汁,那么就需要依赖于吃的类,和喝的的类,而Spring就提供了该依赖,通过applicationContext.xml文件,进行配置
//    饭点类 里面的属性包含  吃的类  和 饮品 类  吃的和 喝的 通过ref属性去进行依赖.
//    依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。
//IOC的常用组件原理
//  Spring常用注解@Controller(声明控制器类)  @Service(用于标注业务层组件) @Repository：用于标注数据访问组件，即DAO组件 @Autowired(Bean的自动装配) @Repository
//		能够明确该类是一个控制器类组件的，就用@Controller；能够明确是一个服务类组件的，就用@Service；能够明确该类是一个数据访问组件的，就用@Repository；不知道他是啥或者不好区分他是啥，但是就是想让他动态装配的就用@Component。
//		@Controller、@Service、@Component、@Repository都是类级别的注解，如果一个方法也想动态装配，就用@Bean。
//		当我们想按类型进行自动装配时，就用@Autowired；当我们想按名称（beanID）进行自动装配时，就用@Resource；
//		当我们需要根据比如配置信息等来动态装配不同的组件时，可以用getBean("beanID")
//	Bean生命周期:
//	Bean的定义——Bean的初始化——Bean的使用——Bean的销毁
//	1.首先实例化一个Bean.
//	2.按照Spring上下文对实例化的Bean进行配置(也就是IOC的注入)
//	3.如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，传递的参数就是Spring配置文件中Bean的id值
//	4.BeanFactoryAware接口，会调用它实现的setBeanFactory(BeanFactory)，传递的是Spring工厂自身(也就是BeanFactory).
//	5.如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文.
//	6.如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，
//	  BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；
//	7.如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
//	8.如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法
//	9.当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；
//	10.最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。
//
//	BeanFactory 和 ApplicationCaontext的区别
//	1.BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory
//	的子接口。
//	BeanFactory使用了延迟加载,就是当使用Bean的时候调用GetBean方法才将该Bean进行实例化加载.
//	ApplicationContext在容器启动的时候一次创建了所有的Bean,并且在启动容器的时候,如果有错误就可以发现spring中存在的配置错误.
//
//	Spring的自动装配原理
//	在使用 @Autowired注解之前需要在Spring配置文件进行配置，<context:annotation-config />。在启动spring
//	IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到 @Autowied、
//	@Resource或 @Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用 @Autowired时，
//	首先在容器中查询对应类型的bean：如果查询结果刚好为一个，就将该bean装配给 @Autowired指定的数据；
//	如果查询的结果不止一个，那么 @Autowired会根据名称来查找,如果查询结果为空那么Spring就会抛出异常.
//	解决异常的方法就是required=false
//
//	@Resource 与 @Autowired的区别
//	(1) @Autowired默认是按照类型装配注入的(ByType装配的)，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。
//	(2) @Resource默认是按照名称来装配注入的(ByName装配的)，只有当找不到与名称匹配的bean才会按照类型来装配注入。
//
//Spring的事物实现方式以及原理:
//	Spring的事物本质也就是数据库对事物的支持.
//什么是事物的传播行为:
//	事物的传播就是当一个事物方法被另外一个事物方法调用的时候,被调用的事物方法应该如何进行.
//	例如methodA事物方法调用methodB事物方法,methodB是继续在调用者methodA的事物中运行呢,还是自己从新开启一个新的事物,这就由
//	methodB来决定
//
//事物的四种特征:
//1.原子性: 原子性是指事物包含的所有操作要么全部成功,要么全部失败回滚,因此事物的操作如果成功那么久必须完全应用到数据库,
//	  如果操作失败则不能对数据库产生任何影响.
//2.一致性:一致性是指事物必须将数据库从一种一致性的状态变为另外一种一致性的状态,也就是指一个事物执行之前和执行之后都必须处
//	 于一致性的状态.拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，
//	 事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
//3.隔离性:隔离性是指多个事物并发访问数据库时,比如操作同一张表,数据库为每个用户开启一个事物,不被其他事物的操作所干扰,
//	 这就是多个并发事物之间的隔离性.(既两个并发事物T1和T2,在事物T1看来,T2要么在T1开始之前就已经结束,
//	 要么T2就在T1结束后开始,这样这个事物就不会感觉到与其他事物并发执行.)
//4.持久性:持久性是指一个事物一旦提交,那么对数据库中的数据的改变是永久性的.即便遇到故障的情况下也不会丢失提交的事物操作.
//	 (例如我们使用JDBC操作数据库时,再提交事物之后,提示用户操作完成的时候就可以认定事物已经正确的提交了,
//	 即使这时候数据库出现问题,也会将我们提交的事物完成.)
//	Spring事物的传播行为本质就是指当多个事物同时存在的时候,Spring如何处理这些事物的行为.
//	Spring的6种传播行为:
//	1.PROPAGATION_REQUIRED
//	如果当前没有事物,就会创建一个事物,如果当前有事物的话那么就会加入该事物.
//	单独调用methodB方法时，因为当前上下文不存在事务，所以会开启一个新的事务。
//	调用methodA方法时，因为当前上下文不存在事务，所以会开启一个新的事务。当执行到methodB时，methodB发现当前上下文有事务，因此就加入到当前事务中来。
//
//	2.PROPAGATION_SUPPORTS 支持当前事物,如果当前有事务,就加入该事物,如果当前事物不存在,就以非事物执行.
//	  单纯的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行。
//
//	3.PROPAGATION_MANDATORY 支持当前的事物,如果当前有事物,那么就加入该事物,如果当前不存在事物那么就抛出异常.
//	  当单独调用methodB时，因为当前没有事务，则会抛出异常throw new IllegalTransactionStateException
//	  (“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用methodA时，methodB则加入
//	  到methodA的事务中，事务地执行。
//
//
//	4.PROPAGATION_REQUIRES_NEW 创建事物,无论当前是否有事务,都会创建一个新的事物.
//	5.PROPAGATION_NOT_SUPPORTED以非事物的方式执行操作,如果当前存在事物,就把当前的事物挂起.
//	6.PROPAGATION_NEVER 以非事物的方式执行操作,如果当前操作存在事物,则就跑出异常.
//	Spring事物的隔离级别:
//他与数据库的隔离级别是类似的.
//	1.ISOLATION_DEFAULT默认隔离界别:使用后端数据库默认的隔离级别。
//	2.ISOLATION_READ_UNCOMMITTED 读未提交,在这种隔离级别下，所有事务能够读取其他事务未提交的数据。读取其他事务未提交的数据，会造成脏读。因此在该种隔离级别下，不能解决脏读、不可重复读和幻读。
//	3.ISOLATION_READ_COMMITTED 读已提交,在这种隔离级别下，所有事务只能读取其他事务已经提交的内容。能够彻底解决脏读的现象。但在这种隔离级别下，会出现一个事务的前后多次的查询中却返回了不同内容的数据的现象，也就是出现了不可重复读。
//	4.ISOLATION_REPEATABLE_READ 可重复读,在这种隔离级别下，所有事务前后多次的读取到的数据内容是不变的。也就是某个事务在执行的过程中，不允许其他事务进行update操作，但允许其他事务进行add操作，造成某个事务前后多次读取到的数据总量不一致的现象，从而产生幻读。
//	5.ISOLATION_SERIALIZABLE 可串行化 在这种隔离级别下，所有的事务顺序执行，所以他们之间不存在冲突，从而能有效地解决脏读、不可重复读和幻读的现象。但是安全和效率不能兼得，这样事务隔离级别，会导致大量的操作超时和锁竞争，从而大大降低数据库的性能，一般不使用这样事务隔离级别。
//为什么采用可重复读隔离级别为默认隔离
//	1.在MySQL5.0的时候出现了一个BUG,(主从复制是基于binlog复制的,binlog有statement:记录的是修改SQL语句,row：记录的是每行实际数据的变更mixed：statement和row模式的混合,
//	MYSQL5.0以前只binlog支持STATEMENT这种格式,而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别.BUG是主库中查询可以得到所有结果,
//	而从库中查询得到的是Empty set,出现了数据不一致原因其实很简单，就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此从机执行的顺序和主机不一致！就会出现主从不一致！
//	解决方案
//	隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当事物A执行delete语句时，会锁住间隙。那么，事物2执行插入语句就会阻塞住！)
//
//
//切点是什么:切面是什么可以理解为JAVA类
//连接点:相当于类中的方法或者异常,
//切点:相当于方法中的方法体也就是业务逻辑部分的代码
//通知:前置通知  :核心业务代码之前编写的代码
//     后置通知  :核心业务代码之后编写的代码
//     全通知    :核心业务代码之前之后编写的代码(此处如果不是用Spring的话  调用MyBatis时需要处理异常以及调用MyBatis接口,调用完毕后需要Close关闭,有了SpringAOP之后  只用关注业务核心的代码  非核心的交给Spring管理如MyBatis的关闭SQL以及等等)
//SpringAOP的实现:
//	SpringAop指的是面向切面编程,功加专注于业务逻辑代码部分,而非业务逻辑代码的部分交给Spring去管理,也同时是面向对象的一个补充,
//	面向对象关注的是一个整体,而切面编程关注的是类内部的细节.
//例子:如果你是一个厨师  没有Spring的时候  你需要去买菜 切菜 做饭(业务逻辑代码 核心代码)  洗碗  而有了Spring之后  买菜洗菜切菜  交给其余人员去处理  你只需要做好饭就行了 饭吃完了洗碗也会交给Spring去工作
//AOP主要一般应用于签名验签、参数校验、日志记录、事务控制、权限控制、性能统计、异常处理等。
//AOP在Spring中的实现原理最核心的就是使用了设计模式中的代理模式
//	什么时候使用:
//	在 Spring 中 AOP 代理使用 JDK 动态代理和 CGLIB 代理来实现，默认如果目标对象是接口，则使用 JDK 动态代理，
//	否则使用 CGLIB 来生成代理类。
//	JDK代理原理:
//	JDK 动态代理是对接口进行的代理:代理类实现了接口,并继承了Proxy类:目标对象与代理对象没有什么直接关系,只是它们都实现了接口
//	并且代理对象执行方法时候,内部最终是委托目标对象执行具体的方法的。
//
//	①JDK动态代理只提供接口的代理，不支持类的代理。他的核心是InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()
//	方法调用目标类中的代码.接着，Proxy利用 InvocationHandler动态创建一个符合接口的的实例,生成目标类的代理对象。
//	invoke(Object  proxy,Method  method,Object[] args)：
//	proxy是最终生成的代理实例; 
//	method 是被代理目标实例调用的方法; 
//	args 是被代理目标实例某个方法的方法的参数列表, 在方法反射调用时使用。
//	2. Proxy类是真正创建代理实例的类，其中主要是使用 Proxy.newProxyInstance来创建。
//
//	CGLIB 代理原理
//	如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。
//	相比 JDK 动态代理对接口进行代理,CGLIB 是对目标对象本身进行代理，所以无论目标对象是否有接口，都可以对目标对象进行代理,
//	其原理是使用字节码生成工具在内存生成一个继承目标对象的代理类，然后创建代理对象实例。
//	创建 CGLIB 动态代理类使用 net.sf.cglib.proxy.Enhancer 类进行创建，它是 CGLIB 动态代理中的核心类.
//	1.创建Enhancer类,调用Enhancer的setClassLoader方法设置加载类.
//	2.调用Enhancer的setSuperclass设置被代理的类
//	3.调用setCallback方法设置方法拦截器.
//	4.调用creat方法创建代理类.
//	5.最后设置被代理类的信息和代理类拦截的方法回调,就可以实现一个代理类.
//
//
//	对比:
//	JDK:
//		JDK 动态代理是通过实现目标类的接口，然后将目标类在构造动态代理时作为参数传入，使代理对象持有目标对象，
//	再通过代理对象的 InvocationHandler 实现动态代理的操作。
//	CGLIB:
//		CGLIB 动态代理是通过配置目标类信息，然后利用 ASM 字节码框架进行生成目标类的子类。当调用代理方法时，
//	通过拦截方法的方式实现代理的操作。
//		 总的来说，JDK 动态代理利用接口实现代理，CGLIB 动态代理利用继承的方式实现代理。
//	Aop应用场景:数据库连接池的关闭,日志的拦截,异常等
//
//
//SpringMVC
//SpringMvc常用注解  @Controller(声明该类为SpringMVC中的Controller) @RequestMapping( 用于映射Web请求，包括访问路径和参数)  @ResponseBody(ResponseBody 支持将返回值放在response内)
//1    用户发送请求至前端控制器DispatcherServlet。
//2、  DispatcherServlet收到请求调用HandlerMapping处理器映射器。
//3、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
//4、  DispatcherServlet调用HandlerAdapter处理器适配器。
//5、  HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。
//6、  Controller执行完成返回ModelAndView。
//7、  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。
//8、  DispatcherServlet将ModelAndView传给ViewReslover视图解析器。
//9、  ViewReslover解析后返回具体View。
//10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。
//11、 DispatcherServlet响应用户
//
//redais
//以键值对形式存储的
//value可以是字符串,Hash值,Map集合,列表list,Set,Zest集合
//zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
//
//zset的成员是唯一的,但分数(score)却可以重复。
//
//zadd 命令：添加元素到集合，元素在集合中存在则更新对应score
//存储类型
//Redis的存储分为内存存储、磁盘存储和log
//
//Dubbo是一个分布式的应用框架,面向接口.
//分部式相当于把项目拆分成许多功能放在不同的服务器上面.
//主要是用于解决一个服务器容量以及性能达到瓶颈的问题采用的优化方式.一台服务器扛不住流量时候,通过添加服务器的方式,将流量平均分布到不同的服务器上.
//Dubbo就是一种分布式框架.
//ORM单一项目架构,将所有功能放置一个服务器上.(如订单服务  用户下单 调用库存减少-->调用用户积分服务)
//
//MVC当访问量较大时,单一应用给服务器带来的加速度越来越小,将应用拆分为不同的应用,此时加速前段页面的Web框架是关键的.
//
//分布式:当垂直应用(单体项目应用)越来越多的时候应用之间的交互是不可避免的,将核心的业务抽取出来,作为独立的服务,逐渐形成稳定的服务中心,此时用于提高业务的复用性分布式RPC框架是关键.
//
//Dubbo的节点:
//Consumer是服务消费者,Provider是服务的提供者,Registry是注册中心,服务只要一启动Provider服务的提供者就会将提供的服务地址放置
//注册中心中去,消费者启动后回合注册中心建立关系,消费者回去找注册中心提供的服务地址,找到之后进行消费.消费者和提供者如果需要建立关系
//则必须要有注册中心.Monitor(监控中心)主要是用于监控服务者和消费者之间的关系,消费者访问提供者的次数,以及时间等情况.
//
//dubbo不使用注册中心可以吗?既然可以为什么还要使用注册中心呢?
//	不使用注册中心可以的,只要知道服务的提供者地址等相关信息,消费者配置之后就可以进行调用,如果服务较少可以不使用注册中心,但是当生产者服务
//	过多,成千上百的时候,每个服务都需要配置,较复杂也容易出错,而且如果一个服务的生产者在运行过程中宕机,消费者不知情,会不断的向生产者发送
//	请求,不断的失败,这时候唯一的办法就是修改服务地址,然后重启服务.所以在这个过程中不使用注册中心的话会相当麻烦,没有办法实现自动化的管理,
//	这时候就需要注册中心来协调服务生产者与消费者之间的关系.
//
//注册中心主要作用如下：
//	1.动态加入,服务提供者通过注册中心动态的把自己暴露给消费者，无需消费者逐个更新配置文件。
//	2.动态发现服务，消费者可以动态发现新的服务，无需重启生效。
//	3.统一配置，避免本地配置导致每个服务配置不一致。
//	4.动态调整，注册中心支持参数动态调整，新参数自动更新到所有相关的服务节点。
//	5.统一管理，依靠注册中心数据，可以统一管理配置服务节点。
//
//dubbo的五个节点
//Provider 服务的提供者,主要是暴漏服务的服务提供方给消费者使用
//Consumer 服务消费者,调用远程服务的服务消费方
//Registry 注册中心,主要是放的是服务的提供者和消费者.
//Monitor  监控中心 统计服务的调用次数和调用时间的监控中心
//Container 服务容器(服务的运行容器)  Spring
//
//1服务容器负责启动，加载，运行服务提供者。
//2服务提供者在启动时，向注册中心注册自己提供的服务。
//3服务消费者在启动时，向注册中心订阅自己所需的服务。
//4注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
//5服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
//6服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
//Zookeeper注册中心(可以理解为数据库)理解为中间件
//
//当Zookeeper挂掉之后生产者和消费者之间还能通信吗?
//      可以的,因为在启动Dubbo容器的时候,消费者就会去Zookeeper拉取注册的生产者提供的地址,并且将其缓存在本地,每次发起调用的时候,都会按照本地的
//      地址列表,以负载均衡的策略去执行.
//      1.如果是监控中心宕机了，只是丢失部分采样数据
//      2.数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务.
//      3.注册中心宕机了之后,因为注册中心对等集群,所以任意一台宕掉后，
//        将自动切换到另一台.如果注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存进行通讯.
//
//负载均衡(使服务器的压力均衡分配达到最佳效果):
//通过配置文件的声明接口处 配置loadbalance   来配置负载均衡的方式(消费者,以及生产者均可配置)
//配置的两大方式:服务级别和方法级别
//服务级别配置 该服务下所有调用的方法均为负载均衡,如果是方法级别 则当前配置的方法为负载均衡.
//负载均衡的四种方式如下:
//1.随机分配(默认使用)从多个服务服务提供者中随机选取一个提供者进行调用,不是每个服务提供者的概率是一样的,根据配置的权重来分配.
//  (通过weight可以配置权重,性能好的机器可以配置权重大一点,反之配置权重少一点.)随机策略会先判断所有的 Invoker 的权重是不是一样的，
//  如果都是一样的，那么处理就比较简单了。使用random.nexInt(length)就可以随机生成一个 Invoker 的序号,根据序号选择对应的 Invoker 。
//  没有配置权重,那么所有的 Invoker 的权重就是一样的，默认是100。 如果权重不一样，那就需要结
//  合权重来设置随机概率了.
//2.轮循分配
//  轮询负载均衡，就是依次的调用所有的 Provider(服务的提供者)。和随机负载均衡策略一样，轮询负载均衡策略也有权重的概念。但是轮询负载均衡算法也
//  有不足的地方，存在慢的 Provider 累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，
//  所有请求都卡在调到第二台上，导致整个系统变慢。
//3.最少活跃数
//  每个服务维护一个活跃数计数器。当A机器开始处理请求，该计数器加1，此时A还未处理完成。若处理完毕则计数器减1。
//  而B机器接受到请求后很快处理完毕。那么A,B的活跃数分别是1，0。当又产生了一个新的请求，则选择B机器去执行(B活跃数最小),
//  这样使慢的机器A收到少的请求。
//  处理一个新的请求时，Consumer (服务消费者)会检查所有 Provider (服务提供者)的活跃数，如果具有最小活跃数的 Invoker 只有一个，直接返回该 Invoker：
//  如果最小活跃数的 Invoker 有多个，且权重不相等同时总权重大于0，这时随机生成一个权重，范围在 (0，totalWeight(总权重)) 之间。
//  最后根据随机生成的权重，来选择 Invoker。
//4.Hash一致性
//  使用一致性 Hash 算法，让相同参数的请求总是发到同一 Provider(服务提供者)。 当某一台 Provider 崩溃时，原本发往该 Provider 的请求，
//  基于虚拟节点，平摊到其它 Provider，不会引起剧烈变动。
//
//生产者调用失败了怎么办:
//	采用容错机制来处理
//	1.Failover Cluster(fai奥 over 可啦siter)(默认使用该容错机制)
//	:当调用出现失败的时候，根据配置的重试次数，会自动从其他可用地址中重新选择一个可用的地址进行调用，直到调用成功，
//	或者是达到重试的上限,Dubbo里默认配置的重试次数是2，也就是说，算上第一次调用，最多会调用3次。
//
//	2.Failfast Cluster
//	这种是 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
//	3Failsafe Cluster
//	失败安全策略  他的核心是即使失败了也不会影响整个调用流程。通常情况下用于旁路系统或流程中，它的失败不影响核心业务的正确性。
//	在实现上，当出现调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。
//	(旁路系统，失败不影响核心流程正确性的场景)
//	4,Failback Cluster
//	失败自动恢复，当主机发生故障，通过Failover进行主备切换后，待故障恢复后，系统自动恢复原始配置。
//	failback如果调用失败的话,此次失败相当于failsafe,返回一个空的结果集,
//	5.Forking Cluster
//	并行调用多个 provider，只要一个成功就立即返回。
//
//
//JVM
//模型:
//JVM内存模型主要分为五个部分:
//1.方法区:存放类的信息,以及类的静态变量,常量,运行时常量池等,并且方法区的大小是可以动态扩展的.
//2堆:堆主要存放的是数组,类的实例对象,字符串的常量等.
//3.Java虚拟栈:主要存放的是JAVA方法运行过程中的内存模型,JAVA虚拟栈会为每一个执行的方法创建一个栈帧的区域,该区域存放的是方法运行时需要的信息如:局部变量,方法返回地址等,
//比如方法执行的过程中需要创建变量时就会将局部变量插入到局部变量表中,局部变量运算传递等在操作数栈中执行,当方法结束后这个方法的栈针将出栈,并且释放内存空间.
//4.本地方法栈.  该区域结构上和Java虚拟栈一样,只不过Java虚拟栈运行的是Java方法的区域,而本地方法栈运行的是本地方法的内存区域.
//5.程序计数器 相对于来说是一个比较小的内存空间,主要用来记录当前线程正在执行哪一个行字节码指令.字节码解释器通过改变程序的计数器来一次读取指令,从而实现代码的流程控制.
//
//GC垃圾回收机制:
//首先怎么判断对象是否能够被回收. 这时候就要提到通过什么算法来判断对象是否要被回收.
//第一个算法:引用计数法:给对象增加一个引用计数器,每当引用一次计数器就加一,当引用失效时计数器减一任何情况下计数器为0时就被判断为不可用对象.但是Java中没有选择引用该计数
//法来管理内存,因为存在对象的循环引用问题(既两个对象相互引用的时就不会回收)
//可达性算法:改算法是通过GC Roots的对象作为初始点,从初始点开始搜索,搜索走过的引用路径也就是引用链当一个对象的GC Roots没有任何引用链相连接时,还需要进行两次筛选,
//一是该方法是否需要执行ﬁnalize()方法,当该对象没有重写ﬁnalize()时或者ﬁnalize()已经被JVM调用时此时才是判断该对象为彻底被回收的对象.
//
//回收的算法
//1.标记算法:首先通过刚才的条件标记处需要回收的对象,在标记完成的时候统一回收所有的标记对象,这种算法的缺点是会差生大量不连续的内存碎片,影响效率.
//2.新生代(复制算法)将内存按照容量划分为大小相同的两块,每次只是用其中一块内存区域,当该区域内存需要回收的时候,会将此区域内还存活的对象赋值到另外一块区域内,再把已经使用过的内存区域一次性清理掉.
//3.老年代(标记整理算法)与标记发相似,但是最后在经过标记算法之后不是直接对对象进行回收,而是将存活对象移至一端,确保没有因为表计算发遗留的内存碎片.然后在清理掉已死亡对象.
//
//
//线程池,集合区别以及底层的实现,MYSQL事务,索引.Innodb和myism区别,b+树,两个引擎底层数据结构,redais几种数据类型,集群部署,分布式锁,SPringBoot自动装配的原理,MQ原理
//
//
//
//Spring常用注解,SpringAop应用场景,JDK线程锁了解情况,以及线程池应用.Collection集合~
//线程池的应用:
//线程池主要是解决线程频繁别使用销毁降低系统效率的问题.
//
//创建线程池的四种方法
//◆创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。newCachedThreadPool
//◆创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待。newFixedThreadPool
//◆创建一个定长线程池，支持定时及周期性任务执行。延迟执行newScheduledThreadPool
//◆创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行newSingleThreadExecutor
//其实这四种方法的实现 都是 new 了一个 ThreadPoolExecutor出来.
//
//线程:
//线程和进程的区别:
//进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位,包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，
//而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
//
//Thread实现了Runnable接口
//run 和 start的区别:
//run是线程体 所有的方法需要写在run方法里面    启动线程需要调用线程的start方法 run方法可以直接被调用 但是不会启动新的线程,只有Start才使启动新线程的方法.
//新建状态：新建线程对象，并没有调用start()方法之前
//
//就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。
//
//运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态
//
//阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态
//
//死亡状态：线程执行结束
//
//创建线程的方法
//1.继承Thread类重写Run方法 Start方法只是启动线程,并不代表线程会立刻执行性,线程之间是抢占是方式执行的.且由JVM调度(创建新子类对象调用子类对象的start方法)
//2.实现RunnAble  接口  重写Run方法  将实现Runnable 的类 实例传入穿件的Thread对象中  thread对象的start方法启动
//3.实现Callable接口，并用其初始化Thread，然后创建Thread实例，并调用start方法 重写call方法
//区别:继承Thread类的缺点Java是单继承 继承了Thread的话 就不能继承其余的类了
//RunnAble 和 Callable的区别:
//(1)Callable规定的方法是call()，Runnable规定的方法是run()。其中Runnable可以提交给Thread来包装下，直接启动一个线程来执行，而Callable则一般都是提交给ExecuteService来执行。
//(2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值得
//(3)call方法可以抛出异常，run方法不可以
//(4)运行Callable任务可以拿到一个Future对象
//Future 提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如果线程没有执行完，Future.get()方法可能会阻塞当前线程的执行；
//
//
//方法: sleep休眠  join 插队 把某一个线程放置前面执行,Yiled 释放当前线程占用的CPU 使重新参与竞争.synchronized 同步锁. 激活的是对象的锁, wait 和 notifly 调用对象锁的notify方法
//唤醒等待队列中的一个线程.currentThread获取当前执行线程的对象
//
//synchronized 多线程保证共享资源安全,,加上线程锁,根本身上使用的是对象的锁,多线程在使用同一个对象的时候
//实际上是激活了一个对象锁,激活的是当前类的默认对象this
//线程安全  :  就是当一个线程访问该对象的时候进行保护,知道该线程访问完毕,其他的线程才能够继续访问,通过synchronized关键字来进行加锁控制解决线程不安全的问题.
//同步代码块的写法 使用时  只要激活的锁是同一个对象的锁,则所有代码块就会同步.
//Lock 和 synchronized 的区别
//1.来源：
//lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；
//
//2.异常是否释放锁：
//synchronized在发生异常时候会自动释放占有的锁；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，
//可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）
//
//3.是否响应中断
//lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；
//
//4.是否知道获取锁
//Lock可以通过trylock来知道有没有获取锁，而synchronized不能；
//
//Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）
//
//5.在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争）
//，此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。
//synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度，
//
//
//线程可处于的状态有:NEW(未启动的线程处于这种状态)
// RUNNBABLE(正在JAVA虚拟机中执行的线程处于这种状态)
// BLOCKED (受阻塞的线程处于这种状态)
// WATTING (无限期等待另一个线程来执行某一个特定的操作的线程处于这种状态)
// TIMEWAITING (等待另一个线程来执行取决于等待时间的操作的线程处于这种状态)
// TERMINATED(已经退出的线程处于这种状态)
// 生产消费是需要协作,其实主要是使用了wait 和  notify 两个方法 前提是由synchronized修饰的(当前持有锁的线程),
// WAIT 调用的是对象锁的wait方法  使当前获得锁的线程释放锁,该线程进入等待状态.
// NOTIFY 唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
// NOTIFYALL 唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；
//--------------------------------------------------
// Wait 和 Seleep的区别
// Wait是Object提供的方法,而Sleep是Thread提供的方法
// Wait 必须在同步代码块内(Synchronize)语句块内
// 是否释放锁对象,调用Wait方法可以
// Sleep本身并不会以释放锁对象,且别的线程不能访问.
// Wait则会释放掉,进入等待队列后 被唤醒后会释放掉等待线程.
// --------------------------------------------------
// 悲观锁
// 当用户操作数据时,别的用户也可能会同时操作数据,所以悲观锁就是每次操作数据时会提前把数据锁起来,只有自己可以修改,然后当使用完毕后再释放锁
// 乐观锁
// 当用户操作数据时,无论其他操作是否上锁当前操作都不上锁,但是修改的时候判断数据是否发生改变,没有改变则进行更新,若发生了改变则重复判断只到成功为止.
//
// 死锁:
// 先看生活中的一个实例，2个人一起吃饭但是只有一双筷子，2人轮流吃（同时拥有2只筷子才能吃）。某一个时候，一个拿了左筷子，
// 一人拿了右筷子，2个人都同时占用一个资源，等待另一个资源，这个时候甲在等待乙吃完并释放它占有的筷子，同理，乙也在等待
// 甲吃完并释放它占有的筷子，这样就陷入了一个死循环，谁也无法继续吃饭.
//
// 某计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出
// 使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样
// 两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。
// 产生死锁的原因:
// 1.竞争资源
//   系统的资源分为两类:可剥夺资源和不可剥夺资源.
//   1.可剥夺资源,是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
//   2.不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放,如打印机就是不可剥夺资源.
//   产生死远的原因就是竞争不可剥夺资源.系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞.
//
// 产生死锁的条件:
//	互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
//	请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
//	不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
//	环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。
//
// 预防死锁的方法:
//   当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了
//   boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，
//   因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁
//解除死锁的方法:
//
// 线程池:
// 线程池采用的是阻塞队列
// 阻塞队列和非阻塞队列的区别:
//    区别:当有一个长度为10的队列容器的时候,当前队列已经满了,阻塞队列会进行等待,等待队列容器中的某一个元素出队时,才能够在像队列内添加,
//    而非阻塞队列 则会造成数据的丢失,出队时也是相同的,非阻塞队列在对队列容器进行获取数据的时候如果队列没有元素,则取出来的元素值为null
//    阻塞队列则是等待有元素进入之后在进行取出元素.
//
// 创建队列:(非阻塞)ConcurreentLinkedQueue   add表示入队.poll出队且移除队列中的元素.
//	  (阻塞队列) BlockingQueue(是个接口) 实现了多个接口如LinkedBlockingQueue等
// 线程的正常状态(新生状态---->就绪状态---->运行状态---->死亡状态)当就绪阶段的时候需要CPU分配资源,此时需要时间(比如2秒),但是线程
// 实际运行时用时3秒 死亡需要2秒(共需要7秒)  但是如果存在于高并发的系统中去时,会有许多线程执行,都需要执行以上的操作,比如有10个线
// 程需要执行100个任务(run方法内的就叫做任务)这100个任务都需要交给这10个线程去进行执行,此时就需要到阻塞队列将这100个任务去执行完
// 毕,这个过程中并不会频繁的创建销毁线程,此时这10个线程相当于一个共享的,等待任务来执行,直到任务执行完完毕(阻塞队列).
//
// ThreadPoolExecutor  ol  =  new ThreadPoolExecutor(1,3,0,TimeUnit.MILLIS,new LinkedBlockingDeque<Runnable>(3))
// 五个参数
// 第1个参数:表示核心线程数
// 第2个参数表示最大线程数
// 第3个参数表示时间
// 第4个参数表示时间的单位
// 第5个参数表workQueue工作队列(LinkedBlockingQeque)新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务
// 5)1.ArrayBlockingQueue:新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到核心线程数后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到最大线程数，则会执行拒绝策略。
//   2.LinkedBlockingQuene基于链表的无界阻塞队列（其实最大容量为Interger.MAX）。由于该队列的近似无界性，当线程池中线程数量达到核心线程数后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到到达最大线程数，因此使用该工作队列时，参数最大线程数其实是不起作用的。
//   3.一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到最大线程数，则执行拒绝策略
//
// 用户提交任务的时候(线程要执行的代码就叫做任务),判断是否大于核心线程数如果没有大于核心线程数则交给核心线程执行任务,如果大于
// 核心线程数的话,则把任务直接放入队列中去,根据定义的队列大小,放入队列,如果队列没有被放置满的话随着核心线程执行任务完毕后,继续
// 调用队列中的任务继续执行,如果队列中任务量大于定义的队列大小(LinkedBlockingDeque处定义得队列大小),则创建新的线程继,
// 并且新的线程继续执行任务,当没有新得任务时根据定义的等待时间销毁创建的线程,创建的新得线程的大小不能大于最大线程数量,
// 否则会报错,拒绝任务,如果创建线程的数量加上核心线程数量小于等于最大线程数则利用新的线程和核心线程进行一个任务的分摊继续操作任务.
//
// 线程池中怎么进行任务的提交:
// 1.execute方法用于提交不需要返回值的任务，利用这种方式提交的任务无法得知是否正常执行
// 2.submit方法用于提交一个任务并带有返回值，这个方法将返回一个Future类型对象。可以通过这个返回对象判断任务是否执行成功,
// 并且可以通过future.get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成。
//
// 关闭线程池的方法:
// 可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。他们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt
// 方法来中断线程，所以无响应中断的任务可能永远无法停止。但是他们存在一定的区别，shutdownNow首先将线程池的状态设置为STOP，
// 然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，
// 然后中断所有正在执行的任务。只要调用了这两个关闭方法的一个，isShutdown就会返回true。当所有的任务都关闭后，才表示线程池关闭成功
// ，这是调用isTerminated方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方
// 法来关闭线程池，如果任务不一定执行完，则可以调用shutdownNow方法。
//
//
// JDK1.5之后提供了内置线程池
//
// 可缓存线程池  使用ExcutorsServiec es = Excutors.newCachedThreadPool()创建可缓存线程池,然后用execute执行线程,底层依旧是使用了
// ThreadPoolExecutor 并且也是一个阻塞队列(因为实现了BlockingQueue接口),并且它的最大线程数是Integer的最大值(采用Integer.MAX_Value求的最大值).
//
// 定长线程池  使用ExcutorsServiec es = Excutors.newFixedThreadPool(3)底层依旧是使用的是ThreadPoolExecutor 只不过是把参数3传入了
// ThreadPoolExecutor中的核心线程数,和最大线程数中.
//
// 定时线程池   使用ScheduledExcutorService ses = Executors.newScheduledThreadPool()采用schedule方法来执行,通过两个参数,时间和
// 时间类型,来决定几秒后执行任务.就是时间的延迟.
//
// 单例线程池   使用ExcutorsServiec es = Excutors.newSingleThreadExecutor() 底层使用的代码  核心线程数和最大线程数都是1,所以始终都都会有一个线程来执行.
//
//MyBatis的一级缓存和二级缓存
//一级缓存基于sqlSession默认开启,在操作数据库时需要构造SqlSession对象，在对象中有一个HashMap用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。
//一级缓存的作用域是SqlSession范围的，当在同一个sqlSession中执行两次相同的sql语句时，第一次执行完毕会将数据库中查询的数据写到缓存（内存），
//第二次查询时会从缓存中获取数据，不再去底层数据库查询，从而提高查询效率。
//需要注意的是，如果SqlSession执行了DML操作（增删改），并且提交到数据库，MyBatis则会清空SqlSession中的一级缓存，这样做的目的是为了保证缓存中存储的是最新的信息，避免出现脏读现象。
//当一个SqlSession结束后该SqlSession中的一级缓存也就不存在了。
//关闭一级缓存后，再次访问，需要再次获取一级缓存，然后才能查找数据，否则会抛出异常。
//
//二级缓存
//二级缓存是mapper级别的缓存。使用二级缓存时，多个SqlSession使用同一个Mapper的sql语句去操作数据库，得到的数据会存在二级缓存区域，
//它同样是使用HashMap进行数据存储。相比一级缓存SqlSession，二级缓存的范围更大，多个Sqlsession可以共用二级缓存，二级缓存是跨SqlSession的。
//二级缓存的作用域是mapper的同一个namespace。不同的sqlSession两次执行相同的namespace下的sql语句，且向sql中传递的参数也相同，
//即最终执行相同的sql语句，则第一次执行完毕会将数据库中查询的数据写到缓存，第二次查询会从缓存中获取数据，不再去底层数据库查询，
//从而提高效率。
//使用其他的缓存如(redis)
//
//Java的类加载机制
//一个Java文件从编码到最终的执行,一般分为两个步骤
//1.编译 :把写好的Java文件通过javac命令符编译为字节码文件,也就是Class文件.
//2.运行 :把编译好的字节码文件(Class文件)交给jvm虚拟机运行.
//而类加载的是JVM虚拟机把class文件中的类信息加载进内存,并且进行解析生成Class对象的过程.
//例子:JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。
//由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。
//类加载的过程主要分为3步:
//1.加载
//  加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。
//2.链接
//  1)验证:主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。
//  主要包括与对文件格式的验证(如常量中是否又不被支持的常量,不合法的其他信息等)
//  元数据的验证,比如该类是否继承了被final修饰的类,是否出现不合理的重载等
//  字节码的验证:保证程序类型转换的合理性等
//  对于符号的验证 :校验符号引用中的访问性（private，public等）是否可被当前类访问等
//  2)准备
//  主要是为类变量分配内存,并且赋予初值。
//  初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。比如8种基本类型的初值，默认为0；
//  引用类型的初值则为null等.
//  3)解析
//  将常量池内的符号引用替换为直接引用的过程
//  举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。
//  在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。
//3.初始化
//  这个阶段主要是对类变量初始化，是执行类构造器的过程。
//  换句话说，只对static修饰的变量或语句进行初始化。
//  如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
//  如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。
//4.最后在使用加载完毕类之后
//
//
// Redis的基本数据类型:
// Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
//
//Java7 和 Java8的特性以及区别
//1.7的特性:
//Switch支持了字符串(本质上是对int类型的匹配)
//实现原理: 通过case后面的str对象调用hashcode()方法，得到一个int类型的hash值，然后用这个hash值来唯一标识这个case.
//当匹配时，首先调用这个字符串的hashcode（）方法，获得一个hash值，用这个hash值与case匹配，若没有则不存在，
//若有则接着调用equals（）方法进行匹配。String变量不能为null ,case后的字符串也不能为null ,否则会出现NullPointerException.
//
//erro和exception的区别
//Exception 和 Error 都是继承了 Throwable(chua 包) 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），
//它是异常处理机制的基本组成类型。
//Exception 和 Error
//Exception 是程序正常运行中，可以预料的意外情况,可以被捕获，进行相应处理。
//Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。
//既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。
//Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，
//这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。
//不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，
//通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。
//NoClassDefFoundError他是Error ClassNotFoundException他是异常
//区别区别二：还有一个区别在于NoClassDefFoundError是JVM运行时通过classpath加载类
//时，找不到对应的类而抛出的错误。ClassNotFoundException是在编译过程中如果可能出现此异常，
//在编译过程中必须将ClassNotFoundException异常抛出！
//
//NoClassDefFoundError发生场景如下：
//    1、类依赖的class或者jar不存在 （简单说就是maven生成运行包后被篡改）
//    2、类文件存在，但是存在不同的域中 （简单说就是引入的类不在对应的包下)
//    3、大小写问题，javac编译的时候是无视大小的，很有可能你编译出来的class文件就与想要的不一样！这个没有做验证
//
//
//    ClassNotFoundException发生场景如下：
//    1、调用class的forName方法时，找不到指定的类
//    2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类
//
//try catch finally 中return返回的执行顺序问题:
//try{
//    retrun 3;
//}catch{
//    e.printStackTrace();
//}finally{
//    return 4;
//}
//
////上边情况下，实际返回的是4；
//
//try{
//    int x = 3;
//    retrun x;
//}catch{
//    e.printStackTrace();
//}finally{
//    x++;
//}
//
////上边情况下，实际返回的3
//因为finally的业务操作是在try业务操作的return返回调用者者之前执行。按照刚才第一种情况，实际情况是，
//执行完try中的业务逻辑就，return返回的操作会先存储到一个临时的堆栈中，此时不给调用者返回，随后执行finally中的业务代码。
//如果finally中有return操作，那么就会把finally中的return值与try中的return值进行替换。随后将最终数据返回给调用者。
//
//
//数据库:
//索引是保证MySQL高效获取数据的排好序的数据结构.
//二次查找树:存储的是以Key-Value形式存储的,key就是索引字段,value字段存放的就是索引所在行的磁盘地址,节点分布的顺序是,
//右边的子元素大于他的父节点元素,左边的元素小于父节点的元素.但是对这种结构进行节点的删除等操作的时候就会出现线性数据的形式.
//如果是线性数据速度依旧不会提高太多,所以要尽量保证所有节点两边的平衡才是关键，也就是平衡算法，平衡算法是一种在B树中插入和删除节点的策略,
//我们把所有的数据进行折半块查找，比如一共100条数据。在30和60的地方分一下，存放30和60的节点就是根节点。30和60就是该节点的关键字，
//100也就是分成了3份，这个节点自动创建三个指针。这三份就是根节点的子节点.子节点的个数=关键字个数+1,下面继续分,拿其中一个子节点举例.把30分成3分,
//10和20当成关键字,下面继续是三个子节点。依次类推.
//B树特征
//每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。
//B树是根据红黑树改造得来的,他是将每个大的节点里面放更多的小的索引的Key-Value.
//每个节点最多有M−1个关键字
//般需要指定其阶数M,阶数指的是一个节点包含的子节点最大数量.
//除根节点外，其余的节点至少有ceil(M/2)−1个关键字（ceilceilceil向上取整函数)
//每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它
//所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同
//
//B+树
//二元组[key,data]，key为记录的键值，key唯一；data为数据记录除key外的数据。
//B+树包含两种节点，一种是非叶子节点(索引节点)，一种是叶子节点。
//B+树与B树，最大的不同是B+树的非叶子节点不保存数据，只用于索引，所有数据都保存在叶子节点
//非叶子节点最多有M−1M-1个关键字，阶数M同时限制了叶子结点最多存储M−1M-1M−1个记录。
//索引节点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，
//右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
//
//  每个叶子节点都存有相邻叶子节点的指针，提高区间访问的性能,叶子节点本身依关键字的大小有小到大顺序链接（范围查找特性）
//  每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。
//  非叶子节点不存储data,只存储索引,这样做的目的是为了存放更多的的索引.
//  叶子节点包含所有的索引字段.
//  只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。
//  B+数可以理解为一个多插平衡树,以一个二叉树的一个分支来看当前分支的右边的子节点内所有的元素大于等于它的父节点,
//  左边的元素都是小于它右边的父节点,大于等于他左边的父节点.
//
//Innodb和MyISAM的区别
//1.MyISAM是非事务安全的，而InnoDB是事务安全的.
//2.MyISAM支持全文类型索引，而InnoDB不支持全文索引
//的.
//MyISAM   实现索引的方式:(非聚集索引,索引和数据分开存储)
//	b+树内,叶子节点data存的是数据地址。索引是索引，数据是数据。索引放在XX.MYI文件中，数据放在XX.MYD文件中，所以也叫非聚集索引。
//	因为MYI后缀结尾文件内存储的是MyISAM引擎的索引字段,他的数据放在MYD后缀的文件内,比如说查询一个查询语句 select a from b where c(假设c是索引) = "1",
//	底层首先判断查询的是不是索引字段,如果是索引字段先去索引文件也就是(MYI)后缀结尾的文件中利用B+树的特性进行一个查询 也就是范围查询,然后把查询出来的指针
//	对应的磁盘文件地址指针节点load出来,然后再内存中比对,就可以比对到要查询的节点,找到对应的节点,key存储的是索引元素,data存储的是索引所在行的磁盘文件地址指针,得到磁盘文件地址指针之后再去
//	MYD文件中快速定位到数据所在行.
//InnoDB  实现方式:(聚集索引,索引和数据存储在一起聚集在一个文件内(以IDB文件后缀结尾的文件))
//	叶子节点data存的是数据本身。索引也是数据。数据和索引存在一个XX.IDB文件中，所以也叫聚集索引。
//	他的表数据本身就是按照B+树组织的一个索引结构文件进行存储的.索引的数据和表的数据都存放在以IDB后缀结尾的文件中,他是存在
//	在一起的,而且InnoDB必须有主键,如果设置了主键，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键,则InnoDB会选择第
//	一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引
//	(ROWID随着行记录的写入而主键递增)。而且在B+树中,所有叶子节点的元素都是以递增的形式存储的,每个表都有一个聚集索引的,
//	所有的记录都是存储在B+树的叶子节点的,基于聚集索引的增删改查的效率是最高的.
//
//两者的区别:
//	1.InnoDb支持事物,MyISM不支持事物.
//	2.InnoDB是一个聚集索引,使用的是B+Tree作为索引结构的,数据和文件都是存储在一起的(以IDB后缀结尾的文件),必须有主键,通过主键索引效率很高.
//	3.MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针,根据指针查找对应数据。
//	总的来说呢(InnoDB的B+树索引的叶子节点存的就是数据文件,而MySIM的B+树的索引叶子节点存储的是数据文件的地址指针.通过地址指针可以找到对应的数据)
//	4.InnoDB必须有主键,MyISM可以没有主键.
//	为什么MyISM不用主键做索引,而InnoDB需要主键做索引原因如下:
//	因为InnoDB是基于B+树的索引组织表,每个表都有一个聚集索引的,所有的记录都是存储在B+树的叶子节点的,基于聚集索引的增删改查的效率是最高的,
//	如果我们定义了主键,那么InnoDB就会把主键当做聚集索引.如果不定义索引那么InnoDB会把把一个不为空的唯一索引作为主键,如果两者都没有那么
//	InnoDB会选择自己隐藏式的创建一个主键索引(聚集索引)
//	而MyISAM的b树叶子节点上存放的不是数据，而是数据的地址。MyISAM按照插入的顺序把值保存在磁盘上，
//	由于行的尺寸是固定的，MyISAM能从表开头跳过所需的字节找到需要的行。
//
//红黑树(二叉平衡树)数据结构
//当树结构出现失衡的时候,树结构就会进行一个旋转,进行树平衡.缺点插入元素过多的时候,也是数据量太大时树的深度较高,查询效率较慢.
//
//SQL优化方式
//使用索引
//1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
//2.尽量避免where字句中进行null值判断,以及使用or,!=或<>,否则将导致引擎放弃索引,而采用全表扫描.
//判断null值时可以使用加默认字段,去报没有null值,比如加默认字段0等.
//要使用or时使用union all   来进行查询
//3.使用模糊查询的时候百分号放置查询值的右侧.
//4. left Join 和 right join区别
//   left join  以作表为主(显示左表的所有数据,右表的数据显示符合条件的)
//   right join  则是  right后面的表显示所有的数据,前面的表显示符合条件的数据
//   inner join 只展示符合条件的数据.
//如何查询SQL的性能的高低:
//	1.根据SQL运行的时间来查看.
//	2.可以通过查看数据库提供的语句执行计划来分析相应的数据信息,例如查看执行计划
//	中对应的 COST(即成本耗费)值,反应了运行这段 SQL 的总体估计成本,通常 COST 低的执行
//	计划要好一些.
//MYSQL事物
//事务（ Transaction）： 是数据库操作的最小工作单元,是作为单个逻辑工作单元执行
//的一系列操作；这些操作作为一个整体一起向系统提交,要么都执行、要么都不执
//行；事务是一组不可再分割的操作集合（工作逻辑单元）；
//什么是事物:比如删除一个人员的时候,需要删除掉该人员的所有信息(包括该人员相关信息 如人员发布的信息,文章,信箱等等)这些数据库的操作就此构成了一个事物
//事物的的四大特性:
//1.原子性: 原子性是指事物包含的所有操作要么全部成功,要么全部失败回滚,因此事物的操作如果成功那么久必须完全应用到数据库,
//	  如果操作失败则不能对数据库产生任何影响.
//2.一致性:一致性是指事物必须将数据库从一种一致性的状态变为另外一种一致性的状态,也就是指一个事物执行之前和执行之后都必须处
//	 于一致性的状态.拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，
//	 事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
//3.隔离性:隔离性是指多个事物并发访问数据库时,比如操作同一张表,数据库为每个用户开启一个事物,不被其他事物的操作所干扰,
//	 这就是多个并发事物之间的隔离性.(既两个并发事物T1和T2,在事物T1开来,T2要么在T1开始之前就已经结束,
//	 要么T2就在T1结束后开始,这样么个事物就不会感觉到与其他事物并发执行.)
//4.持久性:持久性是指一个事物一旦提交,那么对数据库中的数据的改变是永久性的.即便遇到故障的情况下也不会丢失提交的事物操作.
//	 (例如我们使用JDBC操作数据库时,再提交事物之后,提示用户操作完成的时候就可以认定事物已经正确的提交了,
//	 即使这时候数据库出现问题,也会将我们提交的事物完成.)
//
//MySQL的脏读,幻读,不可重复读
//脏读:
//	脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
//	比如张三的工资是3000元事物A把他的工资涨到了5000元,但是事物A没有提交,此时,事务B正在读取张三的工资,读取到的数据为5000元,之后事物A发生了异常,而且事物进行了回滚,
//	张三的工资又降会了3000元,但是事物B读取到的工资为5000,这个就是事物的脏读.
//不可重复读取:
//	是指在一个事物内,多次读取同一条数据,这时候该事物还没有结束,另一个事物修改了该条数据,那么第一个事物再次读取该条数据的时候,可能会导致第一个事物读取
//	到的两条数据可能是不一样的.这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
//	例如:以张三为例,事物A读取到张三的工资为3000元,操作还没有完成,事物还没有提交的时候,这个时候事物B把张三的工资改为8000元的时候,而此时事物A在读取张三的工资时,此时工资变为8000元.在一个事务中前后两次读取的结果并不致，导致了不可重复读。
//幻读:
//	事物A在执行读取的时候,需要两次读取数据的总量,前一次查询总量后,此时事物B执行了新增几条数据并且提交了数据,这个时候事物A读取的数据量和之前统计的数据量不一致,这样就导致了数据的幻读.
//	例如事物A读取库存的时候为100个库存,操作还没有完成的时候,事物B向库存内增加了10条库存的时候,事物A再次读取的时候发现多出了10条库存.这就个就是幻读.
//事物隔离级别:
//	有四种隔离级别:
//	1.读未提交(Read uncommitted):在这种隔离级别下，所有事务能够读取其他事务未提交的数据。读取其他事务未提交的数据，会造成脏读。因此在该种隔离级别下，不能解决脏读、不可重复读和幻读。
//	2.读已提交(Read committed):在这种隔离级别下，所有事务只能读取其他事务已经提交的内容。能够彻底解决脏读的现象。但在这种隔离级别下，会出现一个事务的前后多次的查询中却返回了不同内容的数据的现象，也就是出现了不可重复读。
//	3.可重复读(MySQL默认的隔离级别)(Repeatable read):在这种隔离级别下，所有事务前后多次的读取到的数据内容是不变的。也就是某个事务在执行的过程中，不允许其他事务进行update操作，但允许其他事务进行add操作，造成某个事务前后多次读取到的数据总量不一致的现象，从而产生幻读。
//	4.可串行化(Serializable):在这种隔离级别下，所有的事务顺序执行，所以他们之间不存在冲突，从而能有效地解决脏读、不可重复读和幻读的现象。但是安全和效率不能兼得，这样事务隔离级别，会导致大量的操作超时和锁竞争，从而大大降低数据库的性能，一般不使用这样事务隔离级别。
//为什么采用可重复读隔离级别为默认隔离级别
//	1.在MySQL5.0的时候出现了一个BUG,(主从复制是基于binlog复制的,binlog有statement:记录的是修改SQL语句,row：记录的是每行实际数据的变更mixed：statement和row模式的混合,
//	MYSQL5.0以前只binlog支持STATEMENT这种格式,而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别.BUG是主库中查询可以得到所有结果,
//	而从库中查询得到的是Empty set,出现了数据不一致原因其实很简单，就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此从机执行的顺序和主机不一致！就会出现主从不一致！
//	解决方案
//	隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当事物A执行delete语句时，会锁住间隙。那么，事物2执行插入语句就会阻塞住！)
//
//
//redis基本数据类型:string（字符串），hash（哈希），list（列表）.用到的就只有这三个.
//
//PostGresSQL和MySQL区别
//        1.PostgrSQL支持数组存储,
//	2.也支持Json存储,相比于Text存储效率较高,最主要的是PostGreSQL是一个空间数据库,可以存储空间类型的数据(点(point)线(line)面(box))
//	他们均是以坐标的形式存储的.
//	3.支持地理信息处理扩展,以及MySQL对于时间、日期、间隔等时间类型没有秒以下级别的存储类型,POSQL可以支持到秒一下的级别.
//	4.主要是通过ArcGis这个软件和PostgreSQL进行连接  然后在通过ArcGis 和 ArcGisServer进行连接,对地图进行发布,这样地理数据就会写入数据库中了.
//
//通过执行计划来判断,以及查看SQL执行的一个时间.
//lock 和 syanzed有什么区别
//使用%百分号在左边还是在右边什么时候使用
//
//Object的方法有哪些:
//1.equals方法
//2.hashCode方法
//3.toString方法
//4.notify
//5.notifyAll
//
//HashMap怎么扩容
//设计模式有哪些(单例,工厂模式,)
//工厂模式
//
//单例模式
//单例
//饿汉式(线程安全的):在加载类的时候就会创建类的单例，并保存在类中。
//1.定义类变量实例并直接实例化，在类加载的时候就完成了实例化并保存在类中;
//2.定义无参构造器，用于单例实例.
//3.定义公开方法，返回已创建的单例.
//懒汉式(线程不安全的): 懒汉式就是不在系统加载时就创建类的单例，而是在第一次使用实例的时候再创建。
//1.定义一个私有类变量来存储单例,私有的目的是指外部无法直接获取这个变量，而要使用提供的公共方法来获取.
//2.定义私有构造器，表示只在类内部使用，亦指单例的实例只能在单例类内部创建
//3.定义一个公共的公开的方法来返回该类的实例，由于是懒汉式，需要在第一次使用时生成实例，所以为了线程安全，
//使用synchronized关键字来确保只会生成单例.
//代理模式
//
//JAVA的反射机制
//
//
