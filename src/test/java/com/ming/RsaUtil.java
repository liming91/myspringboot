package com.ming;

import com.ming.util.RSAUtil;
import org.junit.Test;

import java.security.KeyPair;
import java.security.NoSuchAlgorithmException;
import java.util.Map;

/**
 * @Author liming
 * @Date 2023/8/18 16:15
 */
public class RsaUtil {
    /**
     * 一、RSA加密简介
     *
     * 　　RSA加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。
     *
     *
     *
     * 二、RSA加密、签名区别
     *
     * 　　加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举2个例子说明。
     *
     * 第一个场景：战场上，B要给A传递一条消息，内容为某一指令。
     *
     * RSA的加密过程如下：
     *
     * （1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。
     *
     * （2）B用A的公钥对消息进行加密，然后传递给A。
     *
     * （3）A接收到B加密的消息，利用A自己的私钥对消息进行解密。
     *
     * 　　在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。
     *
     *
     *
     * 第二个场景：A收到B发的消息后，需要进行回复“收到”。
     *
     * RSA签名的过程如下：
     *
     * （1）A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。
     *
     * （2）A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。
     *
     * （3）B收到消息后，利用A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。
     *
     * 　　在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。
     *
     *
     *
     * 　　但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，再对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。
     *
     * 　　总结：公钥加密、私钥解密、私钥签名、公钥验签。
     *
     *
     *
     *
     * 脏读:
     * 	脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
     * 	比如张三的工资是3000元事物A把他的工资涨到了5000元,但是事物A没有提交,此时,事务B正在读取张三的工资,读取到的数据为5000元,之后事物A发生了异常,而且事物进行了回滚,
     * 	张三的工资又降会了3000元,但是事物B读取到的工资为5000,这个就是事物的脏读.
     * 不可重复读取:
     * 	是指在一个事物内,多次读取同一条数据,这时候该事物还没有结束,另一个事物修改了该条数据,那么第一个事物再次读取该条数据的时候,可能会导致第一个事物读取
     * 	到的两条数据可能是不一样的.这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
     * 	例如:以张三为例,事物A读取到张三的工资为3000元,操作还没有完成,事物还没有提交的时候,这个时候事物B把张三的工资改为8000元的时候,而此时事物A在读取张三的工资时,此时工资变为8000元.在一个事务中前后两次读取的结果并不致，导致了不可重复读。
     * 幻读:
     * 	事物A在执行读取的时候,需要两次读取数据的总量,前一次查询总量后,此时事物B执行了新增几条数据并且提交了数据,这个时候事物A读取的数据量和之前统计的数据量不一致,这样就导致了数据的幻读.
     * 	例如事物A读取库存的时候为100个库存,操作还没有完成的时候,事物B向库存内增加了10条库存的时候,事物A再次读取的时候发现多出了10条库存.这就个就是幻读.
     * 事物隔离级别:
     * 	有四种隔离级别:
     * 	1.读未提交(Read uncommitted):在这种隔离级别下，所有事务能够读取其他事务未提交的数据。读取其他事务未提交的数据，会造成脏读。因此在该种隔离级别下，不能解决脏读、不可重复读和幻读。
     * 	2.读已提交(Read committed):在这种隔离级别下，所有事务只能读取其他事务已经提交的内容。能够彻底解决脏读的现象。但在这种隔离级别下，会出现一个事务的前后多次的查询中却返回了不同内容的数据的现象，也就是出现了不可重复读。
     * 	3.可重复读(MySQL默认的隔离级别)(Repeatable read):在这种隔离级别下，所有事务前后多次的读取到的数据内容是不变的。也就是某个事务在执行的过程中，不允许其他事务进行update操作，但允许其他事务进行add操作，造成某个事务前后多次读取到的数据总量不一致的现象，从而产生幻读。
     * 	4.可串行化(Serializable):在这种隔离级别下，所有的事务顺序执行，所以他们之间不存在冲突，从而能有效地解决脏读、不可重复读和幻读的现象。但是安全和效率不能兼得，这样事务隔离级别，会导致大量的操作超时和锁竞争，从而大大降低数据库的性能，一般不使用这样事务隔离级别。
     * 为什么采用可重复读隔离级别为默认隔离级别
     * 	1.在MySQL5.0的时候出现了一个BUG,(主从复制是基于binlog复制的,binlog有statement:记录的是修改SQL语句,row：记录的是每行实际数据的变更mixed：statement和row模式的混合,
     * 	MYSQL5.0以前只binlog支持STATEMENT这种格式,而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别.BUG是主库中查询可以得到所有结果,
     * 	而从库中查询得到的是Empty set,出现了数据不一致原因其实很简单，就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此从机执行的顺序和主机不一致！就会出现主从不一致！
     * 	解决方案
     * 	隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当事物A执行delete语句时，会锁住间隙。那么，事物2执行插入语句就会阻塞住！)
     * @throws Exception
     */
    @Test
    public void clientRsaTest() throws Exception {
        //生成公钥和私钥
        RSAUtil.GeneratorKey();
        Map<Integer, String> keyMap = RSAUtil.keyMap;
        System.out.println("随机生成的公钥为:" + keyMap.get(0));
        System.out.println("随机生成的私钥为:" + keyMap.get(1));
        System.out.println("===客户端======");
        //加密的字符串
        String message = "西安";

        //公钥加密message
        String messageEn = RSAUtil.encrypt(message, keyMap.get(0));
        System.out.println(message + "\t加密后的字符串为:" + messageEn);

        //私钥解密
        String messageDe = RSAUtil.decrypt(messageEn, keyMap.get(1));
        System.out.println("解密后的字符串为:" + messageDe);

        //私钥进行签名
        String sign = RSAUtil.sign(message, keyMap.get(1));
        System.out.println("签名===："+sign);



        //公钥验签
        boolean verify = RSAUtil.verify(message, sign, keyMap.get(0));
        System.out.println(verify);


    }
}
